@namespace RazorConsole.Components
@using RazorConsole.Core.Rendering
@using Spectre.Console

@implements IDisposable
@inject ScrollableLayoutCoordinator LayoutCoordinator;

<view-height-scrollable
    data-offset="@ScrollOffset"
    data-lines-to-render="@LinesToRender"
    data-enable-embedded="@IsScrollbarEmbedded.ToString()"
    data-scroll-id="@_scrollId">

    @if (Scrollbar != null)
    {
        <div data-scrollbar="true"
             @onfocusin="OnFocusIn"
             @onfocusout="OnFocusOut"
             @onkeydown="HandleKeyDown"
             data-track-char="@Scrollbar.TrackChar"
             data-thumb-char="@Scrollbar.ThumbChar"
             data-track-color="@ScrollbarTrackColorAttribute"
             data-thumb-color="@ScrollbarThumbColorAttribute"
             data-min-thumb-height="@Scrollbar.MinThumbHeight">
        </div>
    }

    @ChildContent(new ScrollContext(HandleKeyDown, ScrollOffset))
</view-height-scrollable>

@code {
    private readonly string _scrollId = Guid.NewGuid().ToString("N");

    /// <summary>
    /// Number of lines visible at one time.
    /// </summary>
    /// <remarks>
    /// Default is 10. This determines how many items are shown before requiring scrolling.
    /// </remarks>
    /// <remarks>
    /// If using embedded mode with scrollbar, then counts only lines that are inside of container
    /// </remarks>
    [Parameter]
    public int LinesToRender { get; set; } = 10;

    /// <summary>
    /// Current scroll offset (index of the first visible line).
    /// </summary>
    [Parameter]
    public int ScrollOffset { get; set; }

    /// <summary>
    /// Event callback invoked when the scroll offset changes.
    /// </summary>
    [Parameter]
    public EventCallback<int> ScrollOffsetChanged { get; set; }

    /// <summary>
    /// Scrollbar settings. If provided, the scrollbar is enabled.
    /// </summary>
    [Parameter]
    public ScrollbarSettings? Scrollbar { get; set; }

    /// <summary>
    /// Flag that determines will scrollbar be embedded or not.
    /// </summary>
    /// <remarks>
    /// This feature is only active when there is exactly one direct child of type <see cref="Table"/> or <see cref="Panel"/>/<see cref="Border"/>.
    /// If multiple block-level elements are detected, the scrollbar will revert to the default side-rendering behavior.
    /// </remarks>
    /// <value>true</value>
    [Parameter]
    public bool IsScrollbarEmbedded { get; set; } = true;

    [Parameter] public required RenderFragment<ScrollContext> ChildContent { get; set; }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        int maxOffset = LayoutCoordinator.GetMaxOffset(_scrollId);
        int newOffset = ScrollOffset;
        int page = Math.Max(1, LinesToRender);

        switch (e.Key)
        {
            case "ArrowDown":
            case "DownArrow": newOffset += 1; break;
            case "ArrowUp":
            case "UpArrow": newOffset = Math.Max(0, newOffset - 1); break;
            case "PageDown":
            case " ": newOffset += page; break;
            case "PageUp": newOffset = Math.Max(0, newOffset - page); break;
            case "Home": newOffset = 0; break;
        }

        newOffset = Math.Clamp(newOffset, 0, maxOffset);

        if (newOffset != ScrollOffset)
        {
            ScrollOffset = newOffset;
            if (ScrollOffsetChanged.HasDelegate)
                await ScrollOffsetChanged.InvokeAsync(newOffset);
            StateHasChanged();
        }
    }

    private bool _isFocused;

    private string? ScrollbarTrackColorAttribute => !_isFocused ? Scrollbar?.TrackColor.ToHex() : Scrollbar?.TrackFocusedColor.ToHex();

    private string? ScrollbarThumbColorAttribute => !_isFocused ? Scrollbar?.ThumbColor.ToHex() : Scrollbar?.ThumbFocusedColor.ToHex();

    private void OnFocusIn(FocusEventArgs eventArgs)
    {
        _isFocused = true;
        Scrollbar?.OnFocusInCallback?.Invoke(eventArgs);
    }

    private void OnFocusOut(FocusEventArgs eventArgs)
    {
        _isFocused = false;
        Scrollbar?.OnFocusOutCallback?.Invoke(eventArgs);
    }

    public void Dispose() => LayoutCoordinator.Remove(_scrollId);
}

@code{

    public sealed record ScrollContext(Func<KeyboardEventArgs, Task> KeyDownEventHandler, int CurrentOffset);

}
