@namespace RazorConsole.Components

@using Spectre.Console
@typeparam TItem

<scrollable
        data-items-count="@Items.Count"
        data-offset="@ScrollOffset"
        data-page-size="@PageSize"
        data-enable-embedded="@EnableEmbeddedScrollbar.ToString()"
    >
    @ChildContent(new ScrollContext<TItem>(VisibleItems, HandleKeyDown, ScrollOffset, PagesCount))
</scrollable>


@code {
    /// <summary>
    /// Provides scrollable navigation through a list of items with keyboard support.
    /// </summary>
    /// <remarks>
    /// This component manages pagination and keyboard navigation (arrow keys, page up/down, home/end)
    /// for large lists. It exposes only the currently visible items to the render fragment.
    /// The component is generic and works with any item type specified via the TItem type parameter.
    /// </remarks>

    /// <summary>
    /// Complete list of items to make scrollable.
    /// </summary>
    [Parameter]
    public IReadOnlyList<TItem> Items { get; set; } = Array.Empty<TItem>();

    /// <summary>
    /// Number of items visible at one time (page size).
    /// </summary>
    /// <remarks>
    /// Default is 1. This determines how many items are shown before requiring scrolling.
    /// </remarks>
    [Parameter]
    public int PageSize { get; set; } = 1;

    /// <summary>
    /// Child content template that receives the visible items and scroll context.
    /// </summary>
    /// <remarks>
    /// The render fragment receives a <see cref="ScrollContext{TItem}"/> containing the currently
    /// visible items and keyboard event handlers.
    /// </remarks>
    [Parameter]
    public required RenderFragment<ScrollContext<TItem>> ChildContent { get; set; }

    private int _offset;

    /// <summary>
    /// Current scroll offset (index of the first visible item). Automatically clamped to valid range.
    /// </summary>
    /// <remarks>
    /// The value is automatically clamped to valid range [0, Items.Count - PageSize].
    /// </remarks>
    [Parameter]
    public int ScrollOffset
    {
        get => _offset;
        set => _offset = Math.Clamp(value, 0, Math.Max(0, Items.Count - PageSize));
    }

    /// <summary>
    /// Event callback invoked when the scroll offset changes.
    /// </summary>
    [Parameter]
    public EventCallback<int> ScrollOffsetChanged { get; set; }

    /// <summary>
    /// Determines whether the scrollbar should be visually embedded within the border of a <see cref="Table"/> or <see cref="Panel"/>/<see cref="Border"/>.
    /// </summary>
    /// <remarks>
    /// This feature is only active when there is exactly one direct child of type <see cref="Table"/> or <see cref="Panel"/>/<see cref="Border"/>.
    /// If multiple block-level elements are detected, the scrollbar will revert to the default side-rendering behavior.
    /// </remarks>
    /// <value>true</value>
    [Parameter]
    public bool EnableEmbeddedScrollbar { get; set; } = true;

    private IReadOnlyList<TItem> VisibleItems
        => Items.Skip(ScrollOffset).Take(PageSize).ToList();

    private int PagesCount => PageSize >= Items.Count ? 1 : Items.Count - PageSize + 1;

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        int newOffset = ScrollOffset;
        int page = Math.Max(1, PageSize);
        int max = Math.Max(0, Items.Count - page);

        switch (e.Key)
        {
            case "ArrowDown":
            case "DownArrow": newOffset += 1; break;
            case "ArrowUp":
            case "UpArrow": newOffset -= 1; break;
            case "PageDown":
            case " ": newOffset += page; break;
            case "PageUp": newOffset -= page; break;
            case "Home": newOffset = 0; break;
            case "End": newOffset = max; break;
            default: return;
        }

        newOffset = Math.Clamp(newOffset, 0, max);

        if (newOffset != ScrollOffset)
        {
            ScrollOffset = newOffset;
            if (ScrollOffsetChanged.HasDelegate)
                await ScrollOffsetChanged.InvokeAsync(newOffset);
            StateHasChanged();
        }
    }
}

@code {
    /// <summary>
    /// Represents the context passed to the child render fragment containing visible items and scroll state.
    /// </summary>
    /// <typeparam name="T">The type of items in the scrollable list.</typeparam>
    /// <param name="Items">The currently visible items in the scrollable viewport.</param>
    /// <param name="KeyDownEventHandler">The keyboard event handler for navigation (arrow keys, page up/down, etc.).</param>
    /// <param name="CurrentOffset">The current scroll offset (index of the first visible item).</param>
    /// <param name="PagesCount">The total number of available scroll positions.</param>
    public sealed record ScrollContext<T>(IReadOnlyList<T> Items, Func<KeyboardEventArgs,Task> KeyDownEventHandler, int CurrentOffset, int PagesCount)
    {
        /// <summary>
        /// Gets the item at the specified index within the visible items.
        /// </summary>
        /// <param name="i">The index of the item to retrieve.</param>
        /// <returns>The item at the specified index.</returns>
        public T this[int i] => Items[i];

        /// <summary>
        /// Gets the number of visible items.
        /// </summary>
        public int Count => Items.Count;

        /// <summary>
        /// Returns an enumerator that iterates through the visible items.
        /// </summary>
        /// <returns>An enumerator for the visible items.</returns>
        public IEnumerator<T> GetEnumerator() => Items.GetEnumerator();
    }
}
