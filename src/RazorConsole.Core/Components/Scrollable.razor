@namespace RazorConsole.Components
@using RazorConsole.Core.Rendering
@using Spectre.Console

@typeparam TItem

<scrollable
    data-items-count="@Items.Count"
    data-offset="@ScrollOffset"
    data-page-size="@PageSize"
    data-enable-embedded="@IsScrollbarEmbedded.ToString()">

    @if (Scrollbar != null)
    {
        <div data-scrollbar="true"
             @onfocusin="OnFocusIn"
             @onfocusout="OnFocusOut"
             @onkeydown="HandleKeyDown"
             data-track-char="@Scrollbar.TrackChar"
             data-thumb-char="@Scrollbar.ThumbChar"
             data-track-color="@ScrollbarTrackColorAttribute"
             data-thumb-color="@ScrollbarThumbColorAttribute"
             data-min-thumb-height="@Scrollbar.MinThumbHeight">
        </div>
    }

    @ChildContent(new ScrollContext<TItem>(VisibleItems, HandleKeyDown, ScrollOffset, PagesCount))
</scrollable>


@code {

    /// <summary>
    /// Provides scrollable navigation through a list of items with keyboard support.
    /// </summary>
    /// <remarks>
    /// This component manages pagination and keyboard navigation (arrow keys, page up/down, home/end)
    /// for large lists. It exposes only the currently visible items to the render fragment.
    /// The component is generic and works with any item type specified via the TItem type parameter.
    /// </remarks>

    /// <summary>
    /// Complete list of items to make scrollable.
    /// </summary>
    [Parameter]
    public IReadOnlyList<TItem> Items { get; set; } = Array.Empty<TItem>();

    /// <summary>
    /// Number of items visible at one time (page size).
    /// </summary>
    /// <remarks>
    /// Default is 1. This determines how many items are shown before requiring scrolling.
    /// </remarks>
    [Parameter]
    public int PageSize { get; set; } = 1;

    /// <summary>
    /// Child content template that receives the visible items and scroll context.
    /// </summary>
    /// <remarks>
    /// The render fragment receives a <see cref="ScrollContext{TItem}"/> containing the currently
    /// visible items and keyboard event handlers.
    /// </remarks>
    [Parameter]
    public required RenderFragment<ScrollContext<TItem>> ChildContent { get; set; }

    private int _offset;

    /// <summary>
    /// Current scroll offset (index of the first visible item).
    /// </summary>
    /// <remarks>
    /// The value is automatically clamped to valid range [0, Items.Count - PageSize].
    /// </remarks>
    [Parameter]
    public int ScrollOffset
    {
        get => _offset;
        set => _offset = Math.Clamp(value, 0, Math.Max(0, Items.Count - PageSize));
    }

    /// <summary>
    /// Event callback invoked when the scroll offset changes.
    /// </summary>
    [Parameter]
    public EventCallback<int> ScrollOffsetChanged { get; set; }

    /// <summary>
    /// Scrollbar settings. If provided, the scrollbar is enabled.
    /// </summary>
    [Parameter]
    public ScrollbarSettings? Scrollbar { get; set; }

    /// <summary>
    /// Flag that determines will scrollbar be embedded or not.
    /// </summary>
    /// <remarks>
    /// This feature is only active when there is exactly one direct child of type <see cref="Table"/> or <see cref="Panel"/>/<see cref="Border"/>.
    /// If multiple block-level elements are detected, the scrollbar will revert to the default side-rendering behavior.
    /// </remarks>
    /// <value>true</value>
    [Parameter]
    public bool IsScrollbarEmbedded { get; set; } = true;

    private IReadOnlyList<TItem> VisibleItems
        => Items.Skip(ScrollOffset).Take(PageSize).ToList();

    private int PagesCount => PageSize >= Items.Count ? 1 : Items.Count - PageSize + 1;

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        int newOffset = ScrollOffset;
        int page = Math.Max(1, PageSize);
        int max = Math.Max(0, Items.Count - page);

        switch (e.Key)
        {
            case "ArrowDown":
            case "DownArrow": newOffset += 1; break;
            case "ArrowUp":
            case "UpArrow": newOffset -= 1; break;
            case "PageDown":
            case " ": newOffset += page; break;
            case "PageUp": newOffset -= page; break;
            case "Home": newOffset = 0; break;
            case "End": newOffset = max; break;
            default: return;
        }

        newOffset = Math.Clamp(newOffset, 0, max);

        if (newOffset != ScrollOffset)
        {
            ScrollOffset = newOffset;
            if (ScrollOffsetChanged.HasDelegate)
                await ScrollOffsetChanged.InvokeAsync(newOffset);
            StateHasChanged();
        }
    }

    private bool _isFocused;

    private string? ScrollbarTrackColorAttribute => !_isFocused ? Scrollbar?.TrackColor.ToHex() : Scrollbar?.TrackFocusedColor.ToHex();

    private string? ScrollbarThumbColorAttribute => !_isFocused ? Scrollbar?.ThumbColor.ToHex() : Scrollbar?.ThumbFocusedColor.ToHex();

    private void OnFocusIn(FocusEventArgs eventArgs)
    {
        _isFocused = true;
        Scrollbar?.OnFocusInCallback?.Invoke(eventArgs);
    }

    private void OnFocusOut(FocusEventArgs eventArgs)
    {
        _isFocused = false;
        Scrollbar?.OnFocusOutCallback?.Invoke(eventArgs);
    }

}

@code{

    public sealed record ScrollContext<T>(IReadOnlyList<T> Items, Func<KeyboardEventArgs, Task> KeyDownEventHandler, int CurrentOffset, int PagesCount)
    {
        /// <summary>
        /// Gets the item at the specified index within the visible items.
        /// </summary>
        /// <param name="i">The index of the item to retrieve.</param>
        /// <returns>The item at the specified index.</returns>
        public T this[int i] => Items[i];

        /// <summary>
        /// Gets the number of visible items.
        /// </summary>
        public int Count => Items.Count;

        /// <summary>
        /// Returns an enumerator that iterates through the visible items.
        /// </summary>
        /// <returns>An enumerator for the visible items.</returns>
        public IEnumerator<T> GetEnumerator() => Items.GetEnumerator();
    }

}
