@namespace RazorConsole.Components

@using Spectre.Console

@typeparam TItem

<div @onfocus="OnFocus"
     @onfocusout="OnFocusOut"
     @onkeydown="OnKeyDown"
     @attributes="AdditionalAttributes">
    <Rows Expand="@Expand">
        @foreach (var option in Options)
        {
            var isSelected = IsEqual(option, Value);
            var isFocused = IsEqual(option, FocusedValue);
            var indicator = isSelected ? SelectedIndicator : UnselectedIndicator;
            var formattedOption = Format(option);
            <Columns>
                <Markup Content="@($" {indicator} {formattedOption}")"
                        Foreground="@(isFocused ? GetFocusAdjustedColor(SelectedOptionForeground) : GetFocusAdjustedColor(OptionForeground))"
                        Decoration="@(isFocused ? GetFocusAdjustedDecoration(SelectedOptionDecoration) : GetFocusAdjustedDecoration(OptionDecoration))" />
            </Columns>
        }
    </Rows>
</div>

@code {
    /// <summary>
    /// Additional attributes to apply to the root element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary<string, object?>? AdditionalAttributes { get; set; }

    // Basic parameters
    /// <summary>
    /// Indicates whether the select currently has focus.
    /// </summary>
    [Parameter]
    public bool IsFocused { get; set; }

    /// <summary>
    /// Event raised when the focus state changes.
    /// </summary>
    [Parameter]
    public EventCallback<bool> IsFocusedChanged { get; set; }

    /// <summary>
    /// Character used to indicate the focused option.
    /// </summary>
    [Parameter]
    public char SelectedIndicator { get; set; } = '>';

    /// <summary>
    /// Character used to indicate non-focused options.
    /// </summary>
    [Parameter]
    public char UnselectedIndicator { get; set; } = ' ';

    /// <summary>
    /// Available options rendered by the select.
    /// </summary>
    [Parameter]
    public TItem[] Options
    {
        get => _options;
        set => _options = value ?? Array.Empty<TItem>();
    }

    /// <summary>
    /// Custom comparer for items in the list. Default is object.Equals()
    /// </summary>
    [Parameter]
    public IEqualityComparer<TItem>? Comparer { get; set; }

    /// <summary>
    /// Custom formatter for the items in the list. Default is object.ToString()
    /// </summary>
    [Parameter]
    public Func<TItem, string>? Formatter { get; set; }

    /// <summary>
    /// Currently committed option value.
    /// </summary>
    [Parameter]
    public TItem? Value { get; set; }

    /// <summary>
    /// Expands the rows layout to fill available space when true.
    /// </summary>
    [Parameter]
    public bool Expand { get; set; } = false;

    /// <summary>
    /// Event raised when the committed value changes.
    /// </summary>
    [Parameter]
    public EventCallback<TItem> ValueChanged { get; set; }

    /// <summary>
    /// Currently highlighted option during keyboard navigation (may differ from committed Value).
    /// </summary>
    [Parameter]
    public TItem? FocusedValue { get; set; }

    /// <summary>
    /// Event raised when the focused option changes.
    /// </summary>
    [Parameter]
    public EventCallback<TItem?> FocusedValueChanged { get; set; }

    /// <summary>
    /// Foreground color for non-focused options.
    /// </summary>
    [Parameter]
    public Color OptionForeground { get; set; } = Color.White;

    /// <summary>
    /// Text decoration for non-focused options.
    /// </summary>
    [Parameter]
    public Decoration OptionDecoration { get; set; } = Decoration.None;

    /// <summary>
    /// Foreground color for the focused option.
    /// </summary>
    [Parameter]
    public Color SelectedOptionForeground { get; set; } = Color.Chartreuse1;

    /// <summary>
    /// Text decoration for the focused option.
    /// </summary>
    [Parameter]
    public Decoration SelectedOptionDecoration { get; set; } = Decoration.Bold;

    private TItem[] _options = [];

    // Focus-adjusted styling methods
    private Color GetFocusAdjustedColor(Color color) => IsFocused ? color : Color.Grey50;

    private Decoration GetFocusAdjustedDecoration(Decoration decoration) =>
        IsFocused ? decoration : decoration | Decoration.Dim;

    private async Task NotifyFocusedValueChangedAsync()
    {
        if (FocusedValueChanged.HasDelegate)
        {
            await FocusedValueChanged.InvokeAsync(FocusedValue).ConfigureAwait(false);
        }
    }

    private async Task SelectOptionAsync(TItem option)
    {
        Value = option;
        FocusedValue = option;

        if (ValueChanged.HasDelegate)
        {
            await ValueChanged.InvokeAsync(option).ConfigureAwait(false);
        }

        if (FocusedValueChanged.HasDelegate)
        {
            await FocusedValueChanged.InvokeAsync(option).ConfigureAwait(false);
        }

        await InvokeAsync(StateHasChanged).ConfigureAwait(false);
    }
    private async Task OnFocus()
    {
        IsFocused = true;
        EnsureFocusedValue();

        if (IsFocusedChanged.HasDelegate)
        {
            await IsFocusedChanged.InvokeAsync(IsFocused).ConfigureAwait(false);
        }

        await InvokeAsync(StateHasChanged).ConfigureAwait(false);
    }

    private async Task OnFocusOut()
    {
        IsFocused = false;

        if (IsFocusedChanged.HasDelegate)
        {
            await IsFocusedChanged.InvokeAsync(IsFocused).ConfigureAwait(false);
        }

        await InvokeAsync(StateHasChanged).ConfigureAwait(false);
    }

    private async Task OnKeyDown(KeyboardEventArgs? args)
    {
        if (args is null)
        {
            return;
        }

        var key = args.Key;

        if (string.IsNullOrEmpty(key))
        {
            return;
        }

        if (_options.Length == 0)
        {
            return;
        }

        if (IsCommitKey(key) && FocusedValue is not null)
        {
            await SelectOptionAsync(FocusedValue).ConfigureAwait(false);
            return;
        }

        if (IsCancelKey(key))
        {
            FocusedValue = Value;
            await NotifyFocusedValueChangedAsync().ConfigureAwait(false);
            await InvokeAsync(StateHasChanged).ConfigureAwait(false);
            return;
        }

        var selectionChanged = false;

        if (IsDownKey(key))
        {
            selectionChanged = TryMoveSelection(1);
        }
        else if (IsUpKey(key))
        {
            selectionChanged = TryMoveSelection(-1);
        }
        else if (IsTypeAheadCandidate(key))
        {
            selectionChanged = TryTypeAhead(key[0]);
        }

        if (!selectionChanged)
        {
            return;
        }

        await NotifyFocusedValueChangedAsync().ConfigureAwait(false);
        await InvokeAsync(StateHasChanged).ConfigureAwait(false);
    }

    private bool TryMoveSelection(int offset)
    {
        EnsureFocusedValue();

        if (_options.Length == 0)
        {
            return false;
        }

        var currentIndex = FocusedValue is null
            ? -1
            : Array.FindIndex(_options, i => IsEqual(i, FocusedValue));

        if (currentIndex < 0)
        {
            currentIndex = offset > 0 ? -1 : 0;
        }

        var nextIndex = currentIndex + offset;

        if (nextIndex < 0)
        {
            nextIndex = _options.Length - 1;
        }
        else if (nextIndex >= _options.Length)
        {
            nextIndex = 0;
        }

        var nextValue = _options[nextIndex];

        if (IsEqual(nextValue, FocusedValue))
        {
            return false;
        }

        FocusedValue = nextValue;
        return true;
    }

    private string? Format(TItem? item)
    {
        if (item is null)
        {
            return null;
        }
        return Formatter is null ? item.ToString() : Formatter(item);
    }

    private bool IsEqual(TItem? item1, TItem? item2) => Comparer?.Equals(item1, item2) ?? Equals(item1, item2);

    private bool TryTypeAhead(char key)
    {
        EnsureFocusedValue();

        if (char.IsControl(key))
        {
            return false;
        }

        var startIndex = FocusedValue is null
            ? 0
            : Array.FindIndex(_options, i => IsEqual(i, FocusedValue));

        var comparison = StringComparison.CurrentCultureIgnoreCase;
        var prefix = key.ToString();

        for (var i = 0; i < _options.Length; i++)
        {
            var candidateIndex = (startIndex + i + 1) % _options.Length;
            var candidate = _options[candidateIndex];
            var formattedCandidate = Format(_options[candidateIndex]);
            var formattedFocusedValue = Format(FocusedValue);

            if (!string.IsNullOrEmpty(formattedCandidate) && formattedCandidate.StartsWith(prefix, comparison))
            {
                if (!string.Equals(formattedCandidate, formattedFocusedValue, StringComparison.Ordinal))
                {
                    FocusedValue = candidate;
                    return true;
                }

                break;
            }
        }

        return false;
    }

    private static bool IsTypeAheadCandidate(string value)
        => value.Length == 1 && !char.IsControl(value[0]);

    private static bool IsDownKey(string key)
        => string.Equals(key, "DownArrow", StringComparison.OrdinalIgnoreCase)
            || string.Equals(key, "ArrowDown", StringComparison.OrdinalIgnoreCase);

    private static bool IsUpKey(string key)
        => string.Equals(key, "UpArrow", StringComparison.OrdinalIgnoreCase)
            || string.Equals(key, "ArrowUp", StringComparison.OrdinalIgnoreCase);

    private static bool IsCommitKey(string key)
        => string.Equals(key, "Enter", StringComparison.OrdinalIgnoreCase)
            || string.Equals(key, "Return", StringComparison.OrdinalIgnoreCase);

    private static bool IsCancelKey(string key)
        => string.Equals(key, "Escape", StringComparison.OrdinalIgnoreCase)
            || string.Equals(key, "Esc", StringComparison.OrdinalIgnoreCase);

    private void EnsureFocusedValue()
    {
        if (_options.Length == 0)
        {
            FocusedValue = default;
            return;
        }

        if (FocusedValue is not null)
        {
            var index = Array.FindIndex(_options, i => IsEqual(i, FocusedValue));
            if (index >= 0)
            {
                return;
            }
        }

        if (Value is not null)
        {
            var selectedIndex = Array.FindIndex(_options, i => IsEqual(i, Value));
            if (selectedIndex >= 0)
            {
                FocusedValue = Value;
                return;
            }
        }

        FocusedValue = _options[0];
    }
}
